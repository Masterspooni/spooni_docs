import q from "fs";
import G from "path";
function gn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ce = { exports: {} }, g = {}, P = {}, E = {};
function De(e) {
  return typeof e > "u" || e === null;
}
function vn(e) {
  return typeof e == "object" && e !== null;
}
function An(e) {
  return Array.isArray(e) ? e : De(e) ? [] : [e];
}
function yn(e, n) {
  var r, l, i, u;
  if (n)
    for (u = Object.keys(n), r = 0, l = u.length; r < l; r += 1)
      i = u[r], e[i] = n[i];
  return e;
}
function Cn(e, n) {
  var r = "", l;
  for (l = 0; l < n; l += 1)
    r += e;
  return r;
}
function wn(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
E.isNothing = De;
E.isObject = vn;
E.toArray = An;
E.repeat = Cn;
E.isNegativeZero = wn;
E.extend = yn;
function Y(e, n) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = n, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Y.prototype = Object.create(Error.prototype);
Y.prototype.constructor = Y;
Y.prototype.toString = function(n) {
  var r = this.name + ": ";
  return r += this.reason || "(unknown reason)", !n && this.mark && (r += " " + this.mark.toString()), r;
};
var j = Y, xe = E;
function fe(e, n, r, l, i) {
  this.name = e, this.buffer = n, this.position = r, this.line = l, this.column = i;
}
fe.prototype.getSnippet = function(n, r) {
  var l, i, u, o, c;
  if (!this.buffer)
    return null;
  for (n = n || 4, r = r || 75, l = "", i = this.position; i > 0 && `\0\r
\u2028\u2029`.indexOf(this.buffer.charAt(i - 1)) === -1; )
    if (i -= 1, this.position - i > r / 2 - 1) {
      l = " ... ", i += 5;
      break;
    }
  for (u = "", o = this.position; o < this.buffer.length && `\0\r
\u2028\u2029`.indexOf(this.buffer.charAt(o)) === -1; )
    if (o += 1, o - this.position > r / 2 - 1) {
      u = " ... ", o -= 5;
      break;
    }
  return c = this.buffer.slice(i, o), xe.repeat(" ", n) + l + c + u + `
` + xe.repeat(" ", n + this.position - i + l.length) + "^";
};
fe.prototype.toString = function(n) {
  var r, l = "";
  return this.name && (l += 'in "' + this.name + '" '), l += "at line " + (this.line + 1) + ", column " + (this.column + 1), n || (r = this.getSnippet(), r && (l += `:
` + r)), l;
};
var En = fe, me = j, Fn = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
], _n = [
  "scalar",
  "sequence",
  "mapping"
];
function Sn(e) {
  var n = {};
  return e !== null && Object.keys(e).forEach(function(r) {
    e[r].forEach(function(l) {
      n[String(l)] = r;
    });
  }), n;
}
function bn(e, n) {
  if (n = n || {}, Object.keys(n).forEach(function(r) {
    if (Fn.indexOf(r) === -1)
      throw new me('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.');
  }), this.tag = e, this.kind = n.kind || null, this.resolve = n.resolve || function() {
    return !0;
  }, this.construct = n.construct || function(r) {
    return r;
  }, this.instanceOf = n.instanceOf || null, this.predicate = n.predicate || null, this.represent = n.represent || null, this.defaultStyle = n.defaultStyle || null, this.styleAliases = Sn(n.styleAliases || null), _n.indexOf(this.kind) === -1)
    throw new me('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var A = bn, ge = E, W = j, Tn = A;
function le(e, n, r) {
  var l = [];
  return e.include.forEach(function(i) {
    r = le(i, n, r);
  }), e[n].forEach(function(i) {
    r.forEach(function(u, o) {
      u.tag === i.tag && u.kind === i.kind && l.push(o);
    }), r.push(i);
  }), r.filter(function(i, u) {
    return l.indexOf(u) === -1;
  });
}
function kn() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, n, r;
  function l(i) {
    e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (n = 0, r = arguments.length; n < r; n += 1)
    arguments[n].forEach(l);
  return e;
}
function I(e) {
  this.include = e.include || [], this.implicit = e.implicit || [], this.explicit = e.explicit || [], this.implicit.forEach(function(n) {
    if (n.loadKind && n.loadKind !== "scalar")
      throw new W("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
  }), this.compiledImplicit = le(this, "implicit", []), this.compiledExplicit = le(this, "explicit", []), this.compiledTypeMap = kn(this.compiledImplicit, this.compiledExplicit);
}
I.DEFAULT = null;
I.create = function() {
  var n, r;
  switch (arguments.length) {
    case 1:
      n = I.DEFAULT, r = arguments[0];
      break;
    case 2:
      n = arguments[0], r = arguments[1];
      break;
    default:
      throw new W("Wrong number of arguments for Schema.create function");
  }
  if (n = ge.toArray(n), r = ge.toArray(r), !n.every(function(l) {
    return l instanceof I;
  }))
    throw new W("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  if (!r.every(function(l) {
    return l instanceof Tn;
  }))
    throw new W("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  return new I({
    include: n,
    explicit: r
  });
};
var B = I, On = A, Ln = new On("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), In = A, Dn = new In("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), Nn = A, Rn = new Nn("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), Mn = B, te = new Mn({
  explicit: [
    Ln,
    Dn,
    Rn
  ]
}), Bn = A;
function Yn(e) {
  if (e === null)
    return !0;
  var n = e.length;
  return n === 1 && e === "~" || n === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function $n() {
  return null;
}
function Pn(e) {
  return e === null;
}
var jn = new Bn("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: Yn,
  construct: $n,
  predicate: Pn,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
}), Hn = A;
function Un(e) {
  if (e === null)
    return !1;
  var n = e.length;
  return n === 4 && (e === "true" || e === "True" || e === "TRUE") || n === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function Kn(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function qn(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Gn = new Hn("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: Un,
  construct: Kn,
  predicate: qn,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), Wn = E, Jn = A;
function Qn(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function Vn(e) {
  return 48 <= e && e <= 55;
}
function Xn(e) {
  return 48 <= e && e <= 57;
}
function Zn(e) {
  if (e === null)
    return !1;
  var n = e.length, r = 0, l = !1, i;
  if (!n)
    return !1;
  if (i = e[r], (i === "-" || i === "+") && (i = e[++r]), i === "0") {
    if (r + 1 === n)
      return !0;
    if (i = e[++r], i === "b") {
      for (r++; r < n; r++)
        if (i = e[r], i !== "_") {
          if (i !== "0" && i !== "1")
            return !1;
          l = !0;
        }
      return l && i !== "_";
    }
    if (i === "x") {
      for (r++; r < n; r++)
        if (i = e[r], i !== "_") {
          if (!Qn(e.charCodeAt(r)))
            return !1;
          l = !0;
        }
      return l && i !== "_";
    }
    for (; r < n; r++)
      if (i = e[r], i !== "_") {
        if (!Vn(e.charCodeAt(r)))
          return !1;
        l = !0;
      }
    return l && i !== "_";
  }
  if (i === "_")
    return !1;
  for (; r < n; r++)
    if (i = e[r], i !== "_") {
      if (i === ":")
        break;
      if (!Xn(e.charCodeAt(r)))
        return !1;
      l = !0;
    }
  return !l || i === "_" ? !1 : i !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(e.slice(r));
}
function zn(e) {
  var n = e, r = 1, l, i, u = [];
  return n.indexOf("_") !== -1 && (n = n.replace(/_/g, "")), l = n[0], (l === "-" || l === "+") && (l === "-" && (r = -1), n = n.slice(1), l = n[0]), n === "0" ? 0 : l === "0" ? n[1] === "b" ? r * parseInt(n.slice(2), 2) : n[1] === "x" ? r * parseInt(n, 16) : r * parseInt(n, 8) : n.indexOf(":") !== -1 ? (n.split(":").forEach(function(o) {
    u.unshift(parseInt(o, 10));
  }), n = 0, i = 1, u.forEach(function(o) {
    n += o * i, i *= 60;
  }), r * n) : r * parseInt(n, 10);
}
function er(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !Wn.isNegativeZero(e);
}
var nr = new Jn("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: Zn,
  construct: zn,
  predicate: er,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0" + e.toString(8) : "-0" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), Ne = E, rr = A, ir = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function lr(e) {
  return !(e === null || !ir.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function or(e) {
  var n, r, l, i;
  return n = e.replace(/_/g, "").toLowerCase(), r = n[0] === "-" ? -1 : 1, i = [], "+-".indexOf(n[0]) >= 0 && (n = n.slice(1)), n === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : n === ".nan" ? NaN : n.indexOf(":") >= 0 ? (n.split(":").forEach(function(u) {
    i.unshift(parseFloat(u, 10));
  }), n = 0, l = 1, i.forEach(function(u) {
    n += u * l, l *= 60;
  }), r * n) : r * parseFloat(n, 10);
}
var ur = /^[-+]?[0-9]+e/;
function cr(e, n) {
  var r;
  if (isNaN(e))
    switch (n) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (n) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (n) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Ne.isNegativeZero(e))
    return "-0.0";
  return r = e.toString(10), ur.test(r) ? r.replace("e", ".e") : r;
}
function fr(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || Ne.isNegativeZero(e));
}
var tr = new rr("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: lr,
  construct: or,
  predicate: fr,
  represent: cr,
  defaultStyle: "lowercase"
}), ar = B, Re = new ar({
  include: [
    te
  ],
  implicit: [
    jn,
    Gn,
    nr,
    tr
  ]
}), pr = B, Me = new pr({
  include: [
    Re
  ]
}), hr = A, Be = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Ye = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function sr(e) {
  return e === null ? !1 : Be.exec(e) !== null || Ye.exec(e) !== null;
}
function dr(e) {
  var n, r, l, i, u, o, c, f = 0, t = null, s, a, d;
  if (n = Be.exec(e), n === null && (n = Ye.exec(e)), n === null)
    throw new Error("Date resolve error");
  if (r = +n[1], l = +n[2] - 1, i = +n[3], !n[4])
    return new Date(Date.UTC(r, l, i));
  if (u = +n[4], o = +n[5], c = +n[6], n[7]) {
    for (f = n[7].slice(0, 3); f.length < 3; )
      f += "0";
    f = +f;
  }
  return n[9] && (s = +n[10], a = +(n[11] || 0), t = (s * 60 + a) * 6e4, n[9] === "-" && (t = -t)), d = new Date(Date.UTC(r, l, i, u, o, c, f)), t && d.setTime(d.getTime() - t), d;
}
function xr(e) {
  return e.toISOString();
}
var mr = new hr("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: sr,
  construct: dr,
  instanceOf: Date,
  represent: xr
}), gr = A;
function vr(e) {
  return e === "<<" || e === null;
}
var Ar = new gr("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: vr
});
function $e(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var T;
try {
  var yr = $e;
  T = yr("buffer").Buffer;
} catch {
}
var Cr = A, ae = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function wr(e) {
  if (e === null)
    return !1;
  var n, r, l = 0, i = e.length, u = ae;
  for (r = 0; r < i; r++)
    if (n = u.indexOf(e.charAt(r)), !(n > 64)) {
      if (n < 0)
        return !1;
      l += 6;
    }
  return l % 8 === 0;
}
function Er(e) {
  var n, r, l = e.replace(/[\r\n=]/g, ""), i = l.length, u = ae, o = 0, c = [];
  for (n = 0; n < i; n++)
    n % 4 === 0 && n && (c.push(o >> 16 & 255), c.push(o >> 8 & 255), c.push(o & 255)), o = o << 6 | u.indexOf(l.charAt(n));
  return r = i % 4 * 6, r === 0 ? (c.push(o >> 16 & 255), c.push(o >> 8 & 255), c.push(o & 255)) : r === 18 ? (c.push(o >> 10 & 255), c.push(o >> 2 & 255)) : r === 12 && c.push(o >> 4 & 255), T ? T.from ? T.from(c) : new T(c) : c;
}
function Fr(e) {
  var n = "", r = 0, l, i, u = e.length, o = ae;
  for (l = 0; l < u; l++)
    l % 3 === 0 && l && (n += o[r >> 18 & 63], n += o[r >> 12 & 63], n += o[r >> 6 & 63], n += o[r & 63]), r = (r << 8) + e[l];
  return i = u % 3, i === 0 ? (n += o[r >> 18 & 63], n += o[r >> 12 & 63], n += o[r >> 6 & 63], n += o[r & 63]) : i === 2 ? (n += o[r >> 10 & 63], n += o[r >> 4 & 63], n += o[r << 2 & 63], n += o[64]) : i === 1 && (n += o[r >> 2 & 63], n += o[r << 4 & 63], n += o[64], n += o[64]), n;
}
function _r(e) {
  return T && T.isBuffer(e);
}
var Sr = new Cr("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: wr,
  construct: Er,
  predicate: _r,
  represent: Fr
}), br = A, Tr = Object.prototype.hasOwnProperty, kr = Object.prototype.toString;
function Or(e) {
  if (e === null)
    return !0;
  var n = [], r, l, i, u, o, c = e;
  for (r = 0, l = c.length; r < l; r += 1) {
    if (i = c[r], o = !1, kr.call(i) !== "[object Object]")
      return !1;
    for (u in i)
      if (Tr.call(i, u))
        if (!o)
          o = !0;
        else
          return !1;
    if (!o)
      return !1;
    if (n.indexOf(u) === -1)
      n.push(u);
    else
      return !1;
  }
  return !0;
}
function Lr(e) {
  return e !== null ? e : [];
}
var Ir = new br("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: Or,
  construct: Lr
}), Dr = A, Nr = Object.prototype.toString;
function Rr(e) {
  if (e === null)
    return !0;
  var n, r, l, i, u, o = e;
  for (u = new Array(o.length), n = 0, r = o.length; n < r; n += 1) {
    if (l = o[n], Nr.call(l) !== "[object Object]" || (i = Object.keys(l), i.length !== 1))
      return !1;
    u[n] = [i[0], l[i[0]]];
  }
  return !0;
}
function Mr(e) {
  if (e === null)
    return [];
  var n, r, l, i, u, o = e;
  for (u = new Array(o.length), n = 0, r = o.length; n < r; n += 1)
    l = o[n], i = Object.keys(l), u[n] = [i[0], l[i[0]]];
  return u;
}
var Br = new Dr("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: Rr,
  construct: Mr
}), Yr = A, $r = Object.prototype.hasOwnProperty;
function Pr(e) {
  if (e === null)
    return !0;
  var n, r = e;
  for (n in r)
    if ($r.call(r, n) && r[n] !== null)
      return !1;
  return !0;
}
function jr(e) {
  return e !== null ? e : {};
}
var Hr = new Yr("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: Pr,
  construct: jr
}), Ur = B, H = new Ur({
  include: [
    Me
  ],
  implicit: [
    mr,
    Ar
  ],
  explicit: [
    Sr,
    Ir,
    Br,
    Hr
  ]
}), Kr = A;
function qr() {
  return !0;
}
function Gr() {
}
function Wr() {
  return "";
}
function Jr(e) {
  return typeof e > "u";
}
var Qr = new Kr("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: qr,
  construct: Gr,
  predicate: Jr,
  represent: Wr
}), Vr = A;
function Xr(e) {
  if (e === null || e.length === 0)
    return !1;
  var n = e, r = /\/([gim]*)$/.exec(e), l = "";
  return !(n[0] === "/" && (r && (l = r[1]), l.length > 3 || n[n.length - l.length - 1] !== "/"));
}
function Zr(e) {
  var n = e, r = /\/([gim]*)$/.exec(e), l = "";
  return n[0] === "/" && (r && (l = r[1]), n = n.slice(1, n.length - l.length - 1)), new RegExp(n, l);
}
function zr(e) {
  var n = "/" + e.source + "/";
  return e.global && (n += "g"), e.multiline && (n += "m"), e.ignoreCase && (n += "i"), n;
}
function ei(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
var ni = new Vr("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: Xr,
  construct: Zr,
  predicate: ei,
  represent: zr
}), Q;
try {
  var ri = $e;
  Q = ri("esprima");
} catch {
  typeof window < "u" && (Q = window.esprima);
}
var ii = A;
function li(e) {
  if (e === null)
    return !1;
  try {
    var n = "(" + e + ")", r = Q.parse(n, { range: !0 });
    return !(r.type !== "Program" || r.body.length !== 1 || r.body[0].type !== "ExpressionStatement" || r.body[0].expression.type !== "ArrowFunctionExpression" && r.body[0].expression.type !== "FunctionExpression");
  } catch {
    return !1;
  }
}
function oi(e) {
  var n = "(" + e + ")", r = Q.parse(n, { range: !0 }), l = [], i;
  if (r.type !== "Program" || r.body.length !== 1 || r.body[0].type !== "ExpressionStatement" || r.body[0].expression.type !== "ArrowFunctionExpression" && r.body[0].expression.type !== "FunctionExpression")
    throw new Error("Failed to resolve function");
  return r.body[0].expression.params.forEach(function(u) {
    l.push(u.name);
  }), i = r.body[0].expression.body.range, r.body[0].expression.body.type === "BlockStatement" ? new Function(l, n.slice(i[0] + 1, i[1] - 1)) : new Function(l, "return " + n.slice(i[0], i[1]));
}
function ui(e) {
  return e.toString();
}
function ci(e) {
  return Object.prototype.toString.call(e) === "[object Function]";
}
var fi = new ii("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: li,
  construct: oi,
  predicate: ci,
  represent: ui
}), ve = B, z = ve.DEFAULT = new ve({
  include: [
    H
  ],
  explicit: [
    Qr,
    ni,
    fi
  ]
}), _ = E, Pe = j, ti = En, je = H, ai = z, b = Object.prototype.hasOwnProperty, V = 1, He = 2, Ue = 3, X = 4, ie = 1, pi = 2, Ae = 3, hi = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, si = /[\x85\u2028\u2029]/, di = /[,\[\]\{\}]/, Ke = /^(?:!|!!|![a-z\-]+!)$/i, qe = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function ye(e) {
  return Object.prototype.toString.call(e);
}
function F(e) {
  return e === 10 || e === 13;
}
function k(e) {
  return e === 9 || e === 32;
}
function w(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function D(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function xi(e) {
  var n;
  return 48 <= e && e <= 57 ? e - 48 : (n = e | 32, 97 <= n && n <= 102 ? n - 97 + 10 : -1);
}
function mi(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function gi(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function Ce(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? " " : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function vi(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var Ge = new Array(256), We = new Array(256);
for (var L = 0; L < 256; L++)
  Ge[L] = Ce(L) ? 1 : 0, We[L] = Ce(L);
function Ai(e, n) {
  this.input = e, this.filename = n.filename || null, this.schema = n.schema || ai, this.onWarning = n.onWarning || null, this.legacy = n.legacy || !1, this.json = n.json || !1, this.listener = n.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
}
function Je(e, n) {
  return new Pe(
    n,
    new ti(e.filename, e.input, e.position, e.line, e.position - e.lineStart)
  );
}
function p(e, n) {
  throw Je(e, n);
}
function Z(e, n) {
  e.onWarning && e.onWarning.call(null, Je(e, n));
}
var we = {
  YAML: function(n, r, l) {
    var i, u, o;
    n.version !== null && p(n, "duplication of %YAML directive"), l.length !== 1 && p(n, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(l[0]), i === null && p(n, "ill-formed argument of the YAML directive"), u = parseInt(i[1], 10), o = parseInt(i[2], 10), u !== 1 && p(n, "unacceptable YAML version of the document"), n.version = l[0], n.checkLineBreaks = o < 2, o !== 1 && o !== 2 && Z(n, "unsupported YAML version of the document");
  },
  TAG: function(n, r, l) {
    var i, u;
    l.length !== 2 && p(n, "TAG directive accepts exactly two arguments"), i = l[0], u = l[1], Ke.test(i) || p(n, "ill-formed tag handle (first argument) of the TAG directive"), b.call(n.tagMap, i) && p(n, 'there is a previously declared suffix for "' + i + '" tag handle'), qe.test(u) || p(n, "ill-formed tag prefix (second argument) of the TAG directive"), n.tagMap[i] = u;
  }
};
function S(e, n, r, l) {
  var i, u, o, c;
  if (n < r) {
    if (c = e.input.slice(n, r), l)
      for (i = 0, u = c.length; i < u; i += 1)
        o = c.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || p(e, "expected valid JSON character");
    else
      hi.test(c) && p(e, "the stream contains non-printable characters");
    e.result += c;
  }
}
function Ee(e, n, r, l) {
  var i, u, o, c;
  for (_.isObject(r) || p(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), o = 0, c = i.length; o < c; o += 1)
    u = i[o], b.call(n, u) || (n[u] = r[u], l[u] = !0);
}
function N(e, n, r, l, i, u, o, c) {
  var f, t;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), f = 0, t = i.length; f < t; f += 1)
      Array.isArray(i[f]) && p(e, "nested arrays are not supported inside keys"), typeof i == "object" && ye(i[f]) === "[object Object]" && (i[f] = "[object Object]");
  if (typeof i == "object" && ye(i) === "[object Object]" && (i = "[object Object]"), i = String(i), n === null && (n = {}), l === "tag:yaml.org,2002:merge")
    if (Array.isArray(u))
      for (f = 0, t = u.length; f < t; f += 1)
        Ee(e, n, u[f], r);
    else
      Ee(e, n, u, r);
  else
    !e.json && !b.call(r, i) && b.call(n, i) && (e.line = o || e.line, e.position = c || e.position, p(e, "duplicated mapping key")), n[i] = u, delete r[i];
  return n;
}
function pe(e) {
  var n;
  n = e.input.charCodeAt(e.position), n === 10 ? e.position++ : n === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : p(e, "a line break is expected"), e.line += 1, e.lineStart = e.position;
}
function v(e, n, r) {
  for (var l = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; k(i); )
      i = e.input.charCodeAt(++e.position);
    if (n && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (F(i))
      for (pe(e), i = e.input.charCodeAt(e.position), l++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return r !== -1 && l !== 0 && e.lineIndent < r && Z(e, "deficient indentation"), l;
}
function ee(e) {
  var n = e.position, r;
  return r = e.input.charCodeAt(n), !!((r === 45 || r === 46) && r === e.input.charCodeAt(n + 1) && r === e.input.charCodeAt(n + 2) && (n += 3, r = e.input.charCodeAt(n), r === 0 || w(r)));
}
function he(e, n) {
  n === 1 ? e.result += " " : n > 1 && (e.result += _.repeat(`
`, n - 1));
}
function yi(e, n, r) {
  var l, i, u, o, c, f, t, s, a = e.kind, d = e.result, h;
  if (h = e.input.charCodeAt(e.position), w(h) || D(h) || h === 35 || h === 38 || h === 42 || h === 33 || h === 124 || h === 62 || h === 39 || h === 34 || h === 37 || h === 64 || h === 96 || (h === 63 || h === 45) && (i = e.input.charCodeAt(e.position + 1), w(i) || r && D(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", u = o = e.position, c = !1; h !== 0; ) {
    if (h === 58) {
      if (i = e.input.charCodeAt(e.position + 1), w(i) || r && D(i))
        break;
    } else if (h === 35) {
      if (l = e.input.charCodeAt(e.position - 1), w(l))
        break;
    } else {
      if (e.position === e.lineStart && ee(e) || r && D(h))
        break;
      if (F(h))
        if (f = e.line, t = e.lineStart, s = e.lineIndent, v(e, !1, -1), e.lineIndent >= n) {
          c = !0, h = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = o, e.line = f, e.lineStart = t, e.lineIndent = s;
          break;
        }
    }
    c && (S(e, u, o, !1), he(e, e.line - f), u = o = e.position, c = !1), k(h) || (o = e.position + 1), h = e.input.charCodeAt(++e.position);
  }
  return S(e, u, o, !1), e.result ? !0 : (e.kind = a, e.result = d, !1);
}
function Ci(e, n) {
  var r, l, i;
  if (r = e.input.charCodeAt(e.position), r !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, l = i = e.position; (r = e.input.charCodeAt(e.position)) !== 0; )
    if (r === 39)
      if (S(e, l, e.position, !0), r = e.input.charCodeAt(++e.position), r === 39)
        l = e.position, e.position++, i = e.position;
      else
        return !0;
    else
      F(r) ? (S(e, l, i, !0), he(e, v(e, !1, n)), l = i = e.position) : e.position === e.lineStart && ee(e) ? p(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  p(e, "unexpected end of the stream within a single quoted scalar");
}
function wi(e, n) {
  var r, l, i, u, o, c;
  if (c = e.input.charCodeAt(e.position), c !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = l = e.position; (c = e.input.charCodeAt(e.position)) !== 0; ) {
    if (c === 34)
      return S(e, r, e.position, !0), e.position++, !0;
    if (c === 92) {
      if (S(e, r, e.position, !0), c = e.input.charCodeAt(++e.position), F(c))
        v(e, !1, n);
      else if (c < 256 && Ge[c])
        e.result += We[c], e.position++;
      else if ((o = mi(c)) > 0) {
        for (i = o, u = 0; i > 0; i--)
          c = e.input.charCodeAt(++e.position), (o = xi(c)) >= 0 ? u = (u << 4) + o : p(e, "expected hexadecimal character");
        e.result += vi(u), e.position++;
      } else
        p(e, "unknown escape sequence");
      r = l = e.position;
    } else
      F(c) ? (S(e, r, l, !0), he(e, v(e, !1, n)), r = l = e.position) : e.position === e.lineStart && ee(e) ? p(e, "unexpected end of the document within a double quoted scalar") : (e.position++, l = e.position);
  }
  p(e, "unexpected end of the stream within a double quoted scalar");
}
function Ei(e, n) {
  var r = !0, l, i = e.tag, u, o = e.anchor, c, f, t, s, a, d = {}, h, m, y, x;
  if (x = e.input.charCodeAt(e.position), x === 91)
    f = 93, a = !1, u = [];
  else if (x === 123)
    f = 125, a = !0, u = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = u), x = e.input.charCodeAt(++e.position); x !== 0; ) {
    if (v(e, !0, n), x = e.input.charCodeAt(e.position), x === f)
      return e.position++, e.tag = i, e.anchor = o, e.kind = a ? "mapping" : "sequence", e.result = u, !0;
    r || p(e, "missed comma between flow collection entries"), m = h = y = null, t = s = !1, x === 63 && (c = e.input.charCodeAt(e.position + 1), w(c) && (t = s = !0, e.position++, v(e, !0, n))), l = e.line, R(e, n, V, !1, !0), m = e.tag, h = e.result, v(e, !0, n), x = e.input.charCodeAt(e.position), (s || e.line === l) && x === 58 && (t = !0, x = e.input.charCodeAt(++e.position), v(e, !0, n), R(e, n, V, !1, !0), y = e.result), a ? N(e, u, d, m, h, y) : t ? u.push(N(e, null, d, m, h, y)) : u.push(h), v(e, !0, n), x = e.input.charCodeAt(e.position), x === 44 ? (r = !0, x = e.input.charCodeAt(++e.position)) : r = !1;
  }
  p(e, "unexpected end of the stream within a flow collection");
}
function Fi(e, n) {
  var r, l, i = ie, u = !1, o = !1, c = n, f = 0, t = !1, s, a;
  if (a = e.input.charCodeAt(e.position), a === 124)
    l = !1;
  else if (a === 62)
    l = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; a !== 0; )
    if (a = e.input.charCodeAt(++e.position), a === 43 || a === 45)
      ie === i ? i = a === 43 ? Ae : pi : p(e, "repeat of a chomping mode identifier");
    else if ((s = gi(a)) >= 0)
      s === 0 ? p(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? p(e, "repeat of an indentation width identifier") : (c = n + s - 1, o = !0);
    else
      break;
  if (k(a)) {
    do
      a = e.input.charCodeAt(++e.position);
    while (k(a));
    if (a === 35)
      do
        a = e.input.charCodeAt(++e.position);
      while (!F(a) && a !== 0);
  }
  for (; a !== 0; ) {
    for (pe(e), e.lineIndent = 0, a = e.input.charCodeAt(e.position); (!o || e.lineIndent < c) && a === 32; )
      e.lineIndent++, a = e.input.charCodeAt(++e.position);
    if (!o && e.lineIndent > c && (c = e.lineIndent), F(a)) {
      f++;
      continue;
    }
    if (e.lineIndent < c) {
      i === Ae ? e.result += _.repeat(`
`, u ? 1 + f : f) : i === ie && u && (e.result += `
`);
      break;
    }
    for (l ? k(a) ? (t = !0, e.result += _.repeat(`
`, u ? 1 + f : f)) : t ? (t = !1, e.result += _.repeat(`
`, f + 1)) : f === 0 ? u && (e.result += " ") : e.result += _.repeat(`
`, f) : e.result += _.repeat(`
`, u ? 1 + f : f), u = !0, o = !0, f = 0, r = e.position; !F(a) && a !== 0; )
      a = e.input.charCodeAt(++e.position);
    S(e, r, e.position, !1);
  }
  return !0;
}
function Fe(e, n) {
  var r, l = e.tag, i = e.anchor, u = [], o, c = !1, f;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = u), f = e.input.charCodeAt(e.position); f !== 0 && !(f !== 45 || (o = e.input.charCodeAt(e.position + 1), !w(o))); ) {
    if (c = !0, e.position++, v(e, !0, -1) && e.lineIndent <= n) {
      u.push(null), f = e.input.charCodeAt(e.position);
      continue;
    }
    if (r = e.line, R(e, n, Ue, !1, !0), u.push(e.result), v(e, !0, -1), f = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > n) && f !== 0)
      p(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < n)
      break;
  }
  return c ? (e.tag = l, e.anchor = i, e.kind = "sequence", e.result = u, !0) : !1;
}
function _i(e, n, r) {
  var l, i, u, o, c = e.tag, f = e.anchor, t = {}, s = {}, a = null, d = null, h = null, m = !1, y = !1, x;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = t), x = e.input.charCodeAt(e.position); x !== 0; ) {
    if (l = e.input.charCodeAt(e.position + 1), u = e.line, o = e.position, (x === 63 || x === 58) && w(l))
      x === 63 ? (m && (N(e, t, s, a, d, null), a = d = h = null), y = !0, m = !0, i = !0) : m ? (m = !1, i = !0) : p(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, x = l;
    else if (R(e, r, He, !1, !0))
      if (e.line === u) {
        for (x = e.input.charCodeAt(e.position); k(x); )
          x = e.input.charCodeAt(++e.position);
        if (x === 58)
          x = e.input.charCodeAt(++e.position), w(x) || p(e, "a whitespace character is expected after the key-value separator within a block mapping"), m && (N(e, t, s, a, d, null), a = d = h = null), y = !0, m = !1, i = !1, a = e.tag, d = e.result;
        else if (y)
          p(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = c, e.anchor = f, !0;
      } else if (y)
        p(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = c, e.anchor = f, !0;
    else
      break;
    if ((e.line === u || e.lineIndent > n) && (R(e, n, X, !0, i) && (m ? d = e.result : h = e.result), m || (N(e, t, s, a, d, h, u, o), a = d = h = null), v(e, !0, -1), x = e.input.charCodeAt(e.position)), e.lineIndent > n && x !== 0)
      p(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < n)
      break;
  }
  return m && N(e, t, s, a, d, null), y && (e.tag = c, e.anchor = f, e.kind = "mapping", e.result = t), y;
}
function Si(e) {
  var n, r = !1, l = !1, i, u, o;
  if (o = e.input.charCodeAt(e.position), o !== 33)
    return !1;
  if (e.tag !== null && p(e, "duplication of a tag property"), o = e.input.charCodeAt(++e.position), o === 60 ? (r = !0, o = e.input.charCodeAt(++e.position)) : o === 33 ? (l = !0, i = "!!", o = e.input.charCodeAt(++e.position)) : i = "!", n = e.position, r) {
    do
      o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length ? (u = e.input.slice(n, e.position), o = e.input.charCodeAt(++e.position)) : p(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !w(o); )
      o === 33 && (l ? p(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(n - 1, e.position + 1), Ke.test(i) || p(e, "named tag handle cannot contain such characters"), l = !0, n = e.position + 1)), o = e.input.charCodeAt(++e.position);
    u = e.input.slice(n, e.position), di.test(u) && p(e, "tag suffix cannot contain flow indicator characters");
  }
  return u && !qe.test(u) && p(e, "tag name cannot contain such characters: " + u), r ? e.tag = u : b.call(e.tagMap, i) ? e.tag = e.tagMap[i] + u : i === "!" ? e.tag = "!" + u : i === "!!" ? e.tag = "tag:yaml.org,2002:" + u : p(e, 'undeclared tag handle "' + i + '"'), !0;
}
function bi(e) {
  var n, r;
  if (r = e.input.charCodeAt(e.position), r !== 38)
    return !1;
  for (e.anchor !== null && p(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), n = e.position; r !== 0 && !w(r) && !D(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === n && p(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(n, e.position), !0;
}
function Ti(e) {
  var n, r, l;
  if (l = e.input.charCodeAt(e.position), l !== 42)
    return !1;
  for (l = e.input.charCodeAt(++e.position), n = e.position; l !== 0 && !w(l) && !D(l); )
    l = e.input.charCodeAt(++e.position);
  return e.position === n && p(e, "name of an alias node must contain at least one character"), r = e.input.slice(n, e.position), b.call(e.anchorMap, r) || p(e, 'unidentified alias "' + r + '"'), e.result = e.anchorMap[r], v(e, !0, -1), !0;
}
function R(e, n, r, l, i) {
  var u, o, c, f = 1, t = !1, s = !1, a, d, h, m, y;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, u = o = c = X === r || Ue === r, l && v(e, !0, -1) && (t = !0, e.lineIndent > n ? f = 1 : e.lineIndent === n ? f = 0 : e.lineIndent < n && (f = -1)), f === 1)
    for (; Si(e) || bi(e); )
      v(e, !0, -1) ? (t = !0, c = u, e.lineIndent > n ? f = 1 : e.lineIndent === n ? f = 0 : e.lineIndent < n && (f = -1)) : c = !1;
  if (c && (c = t || i), (f === 1 || X === r) && (V === r || He === r ? m = n : m = n + 1, y = e.position - e.lineStart, f === 1 ? c && (Fe(e, y) || _i(e, y, m)) || Ei(e, m) ? s = !0 : (o && Fi(e, m) || Ci(e, m) || wi(e, m) ? s = !0 : Ti(e) ? (s = !0, (e.tag !== null || e.anchor !== null) && p(e, "alias node should not have any properties")) : yi(e, m, V === r) && (s = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : f === 0 && (s = c && Fe(e, y))), e.tag !== null && e.tag !== "!")
    if (e.tag === "?") {
      for (e.result !== null && e.kind !== "scalar" && p(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), a = 0, d = e.implicitTypes.length; a < d; a += 1)
        if (h = e.implicitTypes[a], h.resolve(e.result)) {
          e.result = h.construct(e.result), e.tag = h.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
          break;
        }
    } else
      b.call(e.typeMap[e.kind || "fallback"], e.tag) ? (h = e.typeMap[e.kind || "fallback"][e.tag], e.result !== null && h.kind !== e.kind && p(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + h.kind + '", not "' + e.kind + '"'), h.resolve(e.result) ? (e.result = h.construct(e.result), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : p(e, "cannot resolve a node with !<" + e.tag + "> explicit tag")) : p(e, "unknown tag !<" + e.tag + ">");
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || s;
}
function ki(e) {
  var n = e.position, r, l, i, u = !1, o;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = {}, e.anchorMap = {}; (o = e.input.charCodeAt(e.position)) !== 0 && (v(e, !0, -1), o = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || o !== 37)); ) {
    for (u = !0, o = e.input.charCodeAt(++e.position), r = e.position; o !== 0 && !w(o); )
      o = e.input.charCodeAt(++e.position);
    for (l = e.input.slice(r, e.position), i = [], l.length < 1 && p(e, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; k(o); )
        o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do
          o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !F(o));
        break;
      }
      if (F(o))
        break;
      for (r = e.position; o !== 0 && !w(o); )
        o = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(r, e.position));
    }
    o !== 0 && pe(e), b.call(we, l) ? we[l](e, l, i) : Z(e, 'unknown document directive "' + l + '"');
  }
  if (v(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, v(e, !0, -1)) : u && p(e, "directives end mark is expected"), R(e, e.lineIndent - 1, X, !1, !0), v(e, !0, -1), e.checkLineBreaks && si.test(e.input.slice(n, e.position)) && Z(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && ee(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, v(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    p(e, "end of the stream or a document separator is expected");
  else
    return;
}
function Qe(e, n) {
  e = String(e), n = n || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var r = new Ai(e, n), l = e.indexOf("\0");
  for (l !== -1 && (r.position = l, p(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    ki(r);
  return r.documents;
}
function Ve(e, n, r) {
  n !== null && typeof n == "object" && typeof r > "u" && (r = n, n = null);
  var l = Qe(e, r);
  if (typeof n != "function")
    return l;
  for (var i = 0, u = l.length; i < u; i += 1)
    n(l[i]);
}
function Xe(e, n) {
  var r = Qe(e, n);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new Pe("expected a single document in the stream, but found more");
  }
}
function Oi(e, n, r) {
  return typeof n == "object" && n !== null && typeof r > "u" && (r = n, n = null), Ve(e, n, _.extend({ schema: je }, r));
}
function Li(e, n) {
  return Xe(e, _.extend({ schema: je }, n));
}
P.loadAll = Ve;
P.load = Xe;
P.safeLoadAll = Oi;
P.safeLoad = Li;
var se = {}, U = E, K = j, Ii = z, Di = H, Ze = Object.prototype.toString, ze = Object.prototype.hasOwnProperty, Ni = 9, $ = 10, Ri = 13, Mi = 32, Bi = 33, Yi = 34, en = 35, $i = 37, Pi = 38, ji = 39, Hi = 42, nn = 44, Ui = 45, rn = 58, Ki = 61, qi = 62, Gi = 63, Wi = 64, ln = 91, on = 93, Ji = 96, un = 123, Qi = 124, cn = 125, C = {};
C[0] = "\\0";
C[7] = "\\a";
C[8] = "\\b";
C[9] = "\\t";
C[10] = "\\n";
C[11] = "\\v";
C[12] = "\\f";
C[13] = "\\r";
C[27] = "\\e";
C[34] = '\\"';
C[92] = "\\\\";
C[133] = "\\N";
C[160] = "\\_";
C[8232] = "\\L";
C[8233] = "\\P";
var Vi = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function Xi(e, n) {
  var r, l, i, u, o, c, f;
  if (n === null)
    return {};
  for (r = {}, l = Object.keys(n), i = 0, u = l.length; i < u; i += 1)
    o = l[i], c = String(n[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), f = e.compiledTypeMap.fallback[o], f && ze.call(f.styleAliases, c) && (c = f.styleAliases[c]), r[o] = c;
  return r;
}
function _e(e) {
  var n, r, l;
  if (n = e.toString(16).toUpperCase(), e <= 255)
    r = "x", l = 2;
  else if (e <= 65535)
    r = "u", l = 4;
  else if (e <= 4294967295)
    r = "U", l = 8;
  else
    throw new K("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + U.repeat("0", l - n.length) + n;
}
function Zi(e) {
  this.schema = e.schema || Ii, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = U.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = Xi(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function Se(e, n) {
  for (var r = U.repeat(" ", n), l = 0, i = -1, u = "", o, c = e.length; l < c; )
    i = e.indexOf(`
`, l), i === -1 ? (o = e.slice(l), l = c) : (o = e.slice(l, i + 1), l = i + 1), o.length && o !== `
` && (u += r), u += o;
  return u;
}
function oe(e, n) {
  return `
` + U.repeat(" ", e.indent * n);
}
function zi(e, n) {
  var r, l, i;
  for (r = 0, l = e.implicitTypes.length; r < l; r += 1)
    if (i = e.implicitTypes[r], i.resolve(n))
      return !0;
  return !1;
}
function de(e) {
  return e === Mi || e === Ni;
}
function M(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== 65279 || 65536 <= e && e <= 1114111;
}
function el(e) {
  return M(e) && !de(e) && e !== 65279 && e !== Ri && e !== $;
}
function be(e, n) {
  return M(e) && e !== 65279 && e !== nn && e !== ln && e !== on && e !== un && e !== cn && e !== rn && (e !== en || n && el(n));
}
function nl(e) {
  return M(e) && e !== 65279 && !de(e) && e !== Ui && e !== Gi && e !== rn && e !== nn && e !== ln && e !== on && e !== un && e !== cn && e !== en && e !== Pi && e !== Hi && e !== Bi && e !== Qi && e !== Ki && e !== qi && e !== ji && e !== Yi && e !== $i && e !== Wi && e !== Ji;
}
function fn(e) {
  var n = /^\n* /;
  return n.test(e);
}
var tn = 1, an = 2, pn = 3, hn = 4, J = 5;
function rl(e, n, r, l, i) {
  var u, o, c, f = !1, t = !1, s = l !== -1, a = -1, d = nl(e.charCodeAt(0)) && !de(e.charCodeAt(e.length - 1));
  if (n)
    for (u = 0; u < e.length; u++) {
      if (o = e.charCodeAt(u), !M(o))
        return J;
      c = u > 0 ? e.charCodeAt(u - 1) : null, d = d && be(o, c);
    }
  else {
    for (u = 0; u < e.length; u++) {
      if (o = e.charCodeAt(u), o === $)
        f = !0, s && (t = t || // Foldable line = too long, and not more-indented.
        u - a - 1 > l && e[a + 1] !== " ", a = u);
      else if (!M(o))
        return J;
      c = u > 0 ? e.charCodeAt(u - 1) : null, d = d && be(o, c);
    }
    t = t || s && u - a - 1 > l && e[a + 1] !== " ";
  }
  return !f && !t ? d && !i(e) ? tn : an : r > 9 && fn(e) ? J : t ? hn : pn;
}
function il(e, n, r, l) {
  e.dump = function() {
    if (n.length === 0)
      return "''";
    if (!e.noCompatMode && Vi.indexOf(n) !== -1)
      return "'" + n + "'";
    var i = e.indent * Math.max(1, r), u = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - i), o = l || e.flowLevel > -1 && r >= e.flowLevel;
    function c(f) {
      return zi(e, f);
    }
    switch (rl(n, o, e.indent, u, c)) {
      case tn:
        return n;
      case an:
        return "'" + n.replace(/'/g, "''") + "'";
      case pn:
        return "|" + Te(n, e.indent) + ke(Se(n, i));
      case hn:
        return ">" + Te(n, e.indent) + ke(Se(ll(n, u), i));
      case J:
        return '"' + ol(n) + '"';
      default:
        throw new K("impossible error: invalid scalar style");
    }
  }();
}
function Te(e, n) {
  var r = fn(e) ? String(n) : "", l = e[e.length - 1] === `
`, i = l && (e[e.length - 2] === `
` || e === `
`), u = i ? "+" : l ? "" : "-";
  return r + u + `
`;
}
function ke(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function ll(e, n) {
  for (var r = /(\n+)([^\n]*)/g, l = function() {
    var t = e.indexOf(`
`);
    return t = t !== -1 ? t : e.length, r.lastIndex = t, Oe(e.slice(0, t), n);
  }(), i = e[0] === `
` || e[0] === " ", u, o; o = r.exec(e); ) {
    var c = o[1], f = o[2];
    u = f[0] === " ", l += c + (!i && !u && f !== "" ? `
` : "") + Oe(f, n), i = u;
  }
  return l;
}
function Oe(e, n) {
  if (e === "" || e[0] === " ")
    return e;
  for (var r = / [^ ]/g, l, i = 0, u, o = 0, c = 0, f = ""; l = r.exec(e); )
    c = l.index, c - i > n && (u = o > i ? o : c, f += `
` + e.slice(i, u), i = u + 1), o = c;
  return f += `
`, e.length - i > n && o > i ? f += e.slice(i, o) + `
` + e.slice(o + 1) : f += e.slice(i), f.slice(1);
}
function ol(e) {
  for (var n = "", r, l, i, u = 0; u < e.length; u++) {
    if (r = e.charCodeAt(u), r >= 55296 && r <= 56319 && (l = e.charCodeAt(u + 1), l >= 56320 && l <= 57343)) {
      n += _e((r - 55296) * 1024 + l - 56320 + 65536), u++;
      continue;
    }
    i = C[r], n += !i && M(r) ? e[u] : i || _e(r);
  }
  return n;
}
function ul(e, n, r) {
  var l = "", i = e.tag, u, o;
  for (u = 0, o = r.length; u < o; u += 1)
    O(e, n, r[u], !1, !1) && (u !== 0 && (l += "," + (e.condenseFlow ? "" : " ")), l += e.dump);
  e.tag = i, e.dump = "[" + l + "]";
}
function cl(e, n, r, l) {
  var i = "", u = e.tag, o, c;
  for (o = 0, c = r.length; o < c; o += 1)
    O(e, n + 1, r[o], !0, !0) && ((!l || o !== 0) && (i += oe(e, n)), e.dump && $ === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = u, e.dump = i || "[]";
}
function fl(e, n, r) {
  var l = "", i = e.tag, u = Object.keys(r), o, c, f, t, s;
  for (o = 0, c = u.length; o < c; o += 1)
    s = "", o !== 0 && (s += ", "), e.condenseFlow && (s += '"'), f = u[o], t = r[f], O(e, n, f, !1, !1) && (e.dump.length > 1024 && (s += "? "), s += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), O(e, n, t, !1, !1) && (s += e.dump, l += s));
  e.tag = i, e.dump = "{" + l + "}";
}
function tl(e, n, r, l) {
  var i = "", u = e.tag, o = Object.keys(r), c, f, t, s, a, d;
  if (e.sortKeys === !0)
    o.sort();
  else if (typeof e.sortKeys == "function")
    o.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new K("sortKeys must be a boolean or a function");
  for (c = 0, f = o.length; c < f; c += 1)
    d = "", (!l || c !== 0) && (d += oe(e, n)), t = o[c], s = r[t], O(e, n + 1, t, !0, !0, !0) && (a = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, a && (e.dump && $ === e.dump.charCodeAt(0) ? d += "?" : d += "? "), d += e.dump, a && (d += oe(e, n)), O(e, n + 1, s, !0, a) && (e.dump && $ === e.dump.charCodeAt(0) ? d += ":" : d += ": ", d += e.dump, i += d));
  e.tag = u, e.dump = i || "{}";
}
function Le(e, n, r) {
  var l, i, u, o, c, f;
  for (i = r ? e.explicitTypes : e.implicitTypes, u = 0, o = i.length; u < o; u += 1)
    if (c = i[u], (c.instanceOf || c.predicate) && (!c.instanceOf || typeof n == "object" && n instanceof c.instanceOf) && (!c.predicate || c.predicate(n))) {
      if (e.tag = r ? c.tag : "?", c.represent) {
        if (f = e.styleMap[c.tag] || c.defaultStyle, Ze.call(c.represent) === "[object Function]")
          l = c.represent(n, f);
        else if (ze.call(c.represent, f))
          l = c.represent[f](n, f);
        else
          throw new K("!<" + c.tag + '> tag resolver accepts not "' + f + '" style');
        e.dump = l;
      }
      return !0;
    }
  return !1;
}
function O(e, n, r, l, i, u) {
  e.tag = null, e.dump = r, Le(e, r, !1) || Le(e, r, !0);
  var o = Ze.call(e.dump);
  l && (l = e.flowLevel < 0 || e.flowLevel > n);
  var c = o === "[object Object]" || o === "[object Array]", f, t;
  if (c && (f = e.duplicates.indexOf(r), t = f !== -1), (e.tag !== null && e.tag !== "?" || t || e.indent !== 2 && n > 0) && (i = !1), t && e.usedDuplicates[f])
    e.dump = "*ref_" + f;
  else {
    if (c && t && !e.usedDuplicates[f] && (e.usedDuplicates[f] = !0), o === "[object Object]")
      l && Object.keys(e.dump).length !== 0 ? (tl(e, n, e.dump, i), t && (e.dump = "&ref_" + f + e.dump)) : (fl(e, n, e.dump), t && (e.dump = "&ref_" + f + " " + e.dump));
    else if (o === "[object Array]") {
      var s = e.noArrayIndent && n > 0 ? n - 1 : n;
      l && e.dump.length !== 0 ? (cl(e, s, e.dump, i), t && (e.dump = "&ref_" + f + e.dump)) : (ul(e, s, e.dump), t && (e.dump = "&ref_" + f + " " + e.dump));
    } else if (o === "[object String]")
      e.tag !== "?" && il(e, e.dump, n, u);
    else {
      if (e.skipInvalid)
        return !1;
      throw new K("unacceptable kind of an object to dump " + o);
    }
    e.tag !== null && e.tag !== "?" && (e.dump = "!<" + e.tag + "> " + e.dump);
  }
  return !0;
}
function al(e, n) {
  var r = [], l = [], i, u;
  for (ue(e, r, l), i = 0, u = l.length; i < u; i += 1)
    n.duplicates.push(r[l[i]]);
  n.usedDuplicates = new Array(u);
}
function ue(e, n, r) {
  var l, i, u;
  if (e !== null && typeof e == "object")
    if (i = n.indexOf(e), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (n.push(e), Array.isArray(e))
      for (i = 0, u = e.length; i < u; i += 1)
        ue(e[i], n, r);
    else
      for (l = Object.keys(e), i = 0, u = l.length; i < u; i += 1)
        ue(e[l[i]], n, r);
}
function sn(e, n) {
  n = n || {};
  var r = new Zi(n);
  return r.noRefs || al(e, r), O(r, 0, e, !0, !0) ? r.dump + `
` : "";
}
function pl(e, n) {
  return sn(e, U.extend({ schema: Di }, n));
}
se.dump = sn;
se.safeDump = pl;
var ne = P, dn = se;
function re(e) {
  return function() {
    throw new Error("Function " + e + " is deprecated and cannot be used.");
  };
}
g.Type = A;
g.Schema = B;
g.FAILSAFE_SCHEMA = te;
g.JSON_SCHEMA = Re;
g.CORE_SCHEMA = Me;
g.DEFAULT_SAFE_SCHEMA = H;
g.DEFAULT_FULL_SCHEMA = z;
g.load = ne.load;
g.loadAll = ne.loadAll;
g.safeLoad = ne.safeLoad;
g.safeLoadAll = ne.safeLoadAll;
g.dump = dn.dump;
g.safeDump = dn.safeDump;
g.YAMLException = j;
g.MINIMAL_SCHEMA = te;
g.SAFE_SCHEMA = H;
g.DEFAULT_SCHEMA = z;
g.scan = re("scan");
g.parse = re("parse");
g.compose = re("compose");
g.addConstructor = re("addConstructor");
var hl = g, sl = hl, Ie = sl, dl = "\\ufeff?", xl = typeof process < "u" ? process.platform : "", ml = "^(" + dl + "(= yaml =|---)$([\\s\\S]*?)^(?:\\2|\\.\\.\\.)\\s*$" + (xl === "win32" ? "\\r?" : "") + "(?:\\n)?)", xn = new RegExp(ml, "m");
ce.exports = gl;
ce.exports.test = yl;
function gl(e, n) {
  e = e || "";
  var r = { allowUnsafe: !1 };
  n = n instanceof Object ? { ...r, ...n } : r, n.allowUnsafe = !!n.allowUnsafe;
  var l = e.split(/(\r?\n)/);
  return l[0] && /= yaml =|---/.test(l[0]) ? Al(e, n.allowUnsafe) : {
    attributes: {},
    body: e,
    bodyBegin: 1
  };
}
function vl(e, n) {
  for (var r = 1, l = n.indexOf(`
`), i = e.index + e[0].length; l !== -1; ) {
    if (l >= i)
      return r;
    r++, l = n.indexOf(`
`, l + 1);
  }
  return r;
}
function Al(e, n) {
  var r = xn.exec(e);
  if (!r)
    return {
      attributes: {},
      body: e,
      bodyBegin: 1
    };
  var l = n ? Ie.load : Ie.safeLoad, i = r[r.length - 1].replace(/^\s+|\s+$/g, ""), u = l(i) || {}, o = e.replace(r[0], ""), c = vl(r, e);
  return {
    attributes: u,
    body: o,
    bodyBegin: c,
    frontmatter: i
  };
}
function yl(e) {
  return e = e || "", xn.test(e);
}
var Cl = ce.exports;
const wl = /* @__PURE__ */ gn(Cl);
function mn(e, n, r, l) {
  return e.filter((i) => {
    const u = typeof i == "string" ? i : i.path;
    return u.endsWith(".md") || q.statSync(G.resolve(n ?? "/", u)).isDirectory();
  }).map((i) => {
    const u = typeof i == "string" ? i : i.path, o = G.resolve(n ?? "/", u);
    if (q.statSync(o).isDirectory()) {
      const c = mn(q.readdirSync(o), o, r, l), f = u.split("/").pop() ?? "";
      let t;
      return typeof i != "string" && i.title ? t = i.title : t = (f.charAt(0).toUpperCase() + f.slice(1)).replaceAll("-", " "), c.length ? {
        text: t,
        collapsible: l.collapsible,
        collapsed: l.collapsed,
        items: c
      } : null;
    } else if (u.endsWith(".md") && u[0] !== "_") {
      let c;
      if (l.useFrontmatter) {
        const f = wl(q.readFileSync(G.resolve(n ?? "/", u), { encoding: "utf-8" }));
        f && (c = f.attributes.title);
      }
      return {
        text: c || (u.charAt(0).toUpperCase() + u.slice(1)).slice(0, -3).replaceAll("-", " "),
        link: o.replace(r ?? "", "")
      };
    }
    return null;
  }).filter((i) => !!i);
}
function _l(e = {}) {
  var n;
  return e.contentRoot = (e == null ? void 0 : e.contentRoot) ?? "/", e.contentDirs = (n = e == null ? void 0 : e.contentDirs) != null && n.length ? e.contentDirs : ["/"], e.collapsible = (e == null ? void 0 : e.collapsible) ?? !0, e.collapsed = (e == null ? void 0 : e.collapsed) ?? !0, e.useFrontmatter = (e == null ? void 0 : e.useFrontmatter) ?? !1, e.contentRoot = G.join(process.cwd(), e.contentRoot), mn(e.contentDirs, e.contentRoot, e.contentRoot, e);
}
export {
  _l as getSidebar
};
